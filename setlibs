#! /bin/bash
#
# michael cousins
# http://www.github.com/mcous/kicad-lib
# this script file released into the public domain

# setlibs - adds or replaces the libraries of a kicad project with the libraries from github.com/mcous/kicad-lib
#   default behavior: removes all component and footprint libraries in project file and replaces them with new libraries (excepting the power component library)
#   usage: ./setlibs [flags] [paths to .pro files]
#   examples:
#     replace all libraries in two projects:
#       ./setlibs path/to/project1.pro path/to/project2.pro
#     append only the footprint libraries to a project
#       ./setlibs --append --footprints path/to/project.pro
#   flags:
#     -a, --append      = append new libraries rather than replacing them
#     -p, --prepend     = prepend new libraries rather than replacing them
#     -c, --components  = only add component files
#     -f, --footprints  = only add footprint files
#     -v, --verbose     = verbose output
#     -h, --help        = display this little summary

# constants
# kicad project file options
readonly HEAD_MATCH="[[]"
readonly LIB_MATCH="LibName"
readonly DIR_MATCH="LibDir"
readonly UPDATE_MATCH="update"
# what goes where
readonly C_DIR_HEAD="eeschema"
readonly C_DIR_MATCH=( $DIR_MATCH )
readonly C_LIB_HEAD="eeschema/libraries"
readonly C_LIB_MATCH=( $LIB_MATCH )
readonly F_LIB_DIR_HEAD="pcbnew/libraries"
readonly F_LIB_DIR_MATCH=( $LIB_MATCH $DIR_MATCH )

readonly SHORT_FLAGS=("a" "p" "c" "f" "h" "v")
readonly LONG_FLAGS=("append" "prepend" "components" "footprints" "help" "verbose")

# script flags
REPLACE=true
APPEND=false
PREPEND=false
COMPONENTS=true
FOOTPRINTS=true
# debugging
VERBOSE=false

# current program options
OPTS=()
PRJ=()

# library lists
COMPS=()
FOOTS=()

# functions
function go () {
  # parse input
  checkinput $@
  # check options are good
  checkopts
  # run with it
  run
}

# get the absolute location of the script so I can get directory paths
# solution from http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
function getScriptLoc () {
  SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  echov "script is running from: $SCRIPT_DIR"
}

# help function
function help () {
  echo ""
  echo "setlibs - adds or replaces the libraries of a kicad project with the libraries from github.com/mcous/kicad-lib"
  echo "  default behavior: removes all component and footprint libraries in project file and replaces them with new libraries (excepting the power component library)"
  echo "  usage: ./setlibs [flags] [paths/to/project/files]"
  echo "  examples:"
  echo "    replace all libraries in two projects:"
  echo "      ./setlibs path/to/project1.pro path/to/project2.pro"
  echo "    append only the footprint libraries to a project"
  echo "      ./setlibs --append --footprints path/to/project.pro"
  echo "  flags: "
  echo "    -a, --append      = append new libraries rather than replacing them"
  echo "    -p, --prepend     = prepend new libraries rather than replacing them"
  echo "    -c, --components  = only add component files"
  echo "    -f, --footprints  = only add footprint files"
  echo "    -v, --verbose     = verbose output"
  echo "    -h, --help        = display this little summary"
  exit 0
}

# check the input to make sure that any options are correct and the file(s) exists
function checkinput () {
  local inv=false
  local shortMatch="^-[a-z]+$"
  local longMatch="^-{2}[a-z][a-z]+$"
  local proMatch="[a-z]+\.pro$"

  for ARG in "$@"; do
    local valid=false
    # check if its a short flag
    if [[ $ARG =~ $shortMatch ]]; then
      # break up the options if needed
      local len=${#ARG}
      while [ $len -gt 1 ]; do
        # check if it's a valid short flag
        local flag=${ARG:($len-1):1}
        for VALIDOPT in "${SHORT_FLAGS[@]}"; do
          if [ "$flag" = "$VALIDOPT" ]; then
            valid=true
            OPTS+=("$VALIDOPT")
            break
          fi
        done
        let "len -= 1"
      done
      # if invalid input
      if ! $valid; then
        echo "ERROR: $ARG is not a valid option"
      fi

    # else check of its a long flag
    elif [[ $ARG =~ $longMatch ]]; then
      # check if it's a valid long flag
      local flag=${ARG:2}
      for VALIDOPT in "${LONG_FLAGS[@]}"; do
        if [ "$flag" = "$VALIDOPT" ]; then
          valid=true
          OPTS+=("$VALIDOPT")
          break
        fi
      done
      if ! $valid; then
        echo "ERROR: $ARG is not a valid option"
      fi

    # else check if its a project file
    elif [[ $ARG =~ $proMatch ]]; then
      # check if file exists
      if [ -e $ARG ]; then
        PRJ+=( $ARG )
        valid=true
      else
        echo "ERROR: $ARG does not exist"
      fi

    # else input is invalid
    else
      echo "ERROR: $ARG is not valid input"
    fi

    # throw the invalid flag
    if ! $valid; then
      inv=true
    fi
  done

  # if there were errors, help and exit
  if $inv; then
    help
  fi
}

# check for conflicting options and set script flags
function checkopts () {
  # set the flags
  for OP in ${OPTS[@]}; do
    if [ "${OP:0:1}" = "h" ]; then
      help
    elif [ "${OP:0:1}" = "a" ]; then
      APPEND=true
      REPLACE=false
    elif [ "${OP:0:1}" = "p" ]; then
      PREPEND=true
      REPLACE=false
    elif [ "${OP:0:1}" = "c" ]; then
      FOOTPRINTS=false
    elif [ "${OP:0:1}" = "f" ]; then
      COMPONENTS=false
    elif [ "${OP:0:1}" = "v" ]; then
      VERBOSE=true
    fi
  done

  local inv=false
  # make sure there are no conflicting flags
  if $APPEND && $PREPEND; then
    echo "ERROR: append and prepend options are mutually exclusive"
    inv=true
  fi
  if ! $FOOTPRINTS && ! $COMPONENTS; then
    echo "ERROR: components-only and footprints-only options are mutually exclusive"
    inv=true
  fi
  # also make sure there are project files
  if [ ! "${PRJ[0]}" ]; then
    echo "ERROR: no kicad project files entered"
    inv=true
  fi

  # if invalid flag, help and exit
  if $inv; then
    help
  fi
}

function buildLists () {
  if $COMPONENTS; then
    local dir="$SCRIPT_DIR/components/*.lib"
    for C in $dir; do
      local f=`basename $C`
      COMPS+=(${f%%.lib})
    done
    echov "component libraries: ${COMPS[@]}"
  fi

  if $FOOTPRINTS; then
    local dir="$SCRIPT_DIR/footprints/*.mod"
    for F in $dir; do
      local f=`basename $F`
      FOOTS+=(${f%%.mod})
    done
    echov "footprint libraries: ${FOOTS[@]}"
  fi
}

# do the magic
function run () {
  # get the directory of the script for later
  getScriptLoc
 
  echov "running on ${#PRJ[*]} projects"

  # do this for every project
  for P in "${PRJ[@]}"; do
    echo "fixing $P"
    echov "with these options:"
    echov -e "\treplace libraries: $REPLACE"
    echov -e "\tappend libraries: $APPEND"
    echov -e "\tprepend libraries: $PREPEND"
    echov -e "\tuse components: $COMPONENTS"
    echov -e "\tuse footprints: $FOOTPRINTS"
    # back that shit up
    cp -f "$P" "$P".old
    echo "$P backed up to $P.old"
    # create my temp file
    rm -f $P.temp
    touch $P.temp

    # build the library lists
    buildLists
    # read in the old file and build the new
    readAndBuild

    # clean up
    cleanup

    # notify
    echo "new libraries added to $P"
  done
}

# reads in the project file line by line and outputs to $P.temp accordingly
function readAndBuild () {
  # i/o
  local currHead=""
  local outLine=""
  # input matching
  local match=()
  local currMatch=""
  # library variables
  local lookingForEnd=false
  local libList=()

  # read the file into an array - cupper limit is 500 just in case
  while read currLine && (( inRead < 500 )); do
    echov -e "in:\t$currLine"
    outLine=$currLine
    # default is write to output
    local write=true

    # check for end of section
    if $lookingForEnd && ! [[ $currLine =~ $currMatch ]]; then
      echov "end of section found for $currMatch"
      lookingForEnd=false
      if [[ $currMatch =~ $LIB_MATCH ]]; then
        # components
        if [[ $currHead =~ $C_LIB_HEAD ]]; then
          if $PREPEND; then
            libList=( ${COMPS[@]} ${libList[@]} )
            echov "prepending component libraries"
          elif $APPEND; then
            libList=( ${libList[@]} ${COMPS[@]}  )
            echov "appending component libraries" 
          else
            libList=( ${COMPS[@]} "power" )
            echov "replacing component libraries"
          fi
        # footprints
        elif [[ $currHead =~ $F_LIB_HEAD ]]; then
          if $PREPEND; then
            libList=( ${FOOTS[@]} ${libList[@]} )
            echov "prepending footprint libraries"
          elif $APPEND; then
            libList=( ${libList[@]} ${FOOTS[@]}  )
            echov "appending footprint libraries"
          else
            libList=( ${FOOTS[@]} )
            echov "replacing footprint libraries"
          fi
        fi

        # loop and fix the libs
        local libNum=1
        for li in ${libList[@]}; do
          local output="$LIB_MATCH$libNum=$li"
          echov -e "out:\t$output"
          echo $output >> $P.temp
          let libNum++
        done
        echov "all libraries outputted"
      fi
      #echov -e "\n"
    fi

    # reset curren match
    currMatch=""

    # check for last updated
    if [[ $currLine =~ $UPDATE_MATCH ]]; then
      local now=`date +"%d/%m/%Y %T"`
      outLine="$UPDATE_MATCH=$now"
    # check for heading
    elif [[ $currLine =~ $HEAD_MATCH ]]; then
      currHead=$currLine
      # set matches accordingly
      if [[ $currHead =~ $C_LIB_HEAD ]] && $COMPONENTS; then
        echov "component library heading found"
        match=( ${C_LIB_MATCH[@]} )
        echov "now looking for: ${match[@]}"
        libList=()
      elif [[ $currHead =~ $C_DIR_HEAD ]] && $COMPONENTS; then
        echov "component directory heading found"
        match=( ${C_DIR_MATCH[@]} )
        echov "now looking for: ${match[@]}"
      elif [[ $currHead =~ $F_LIB_DIR_HEAD ]] && $FOOTPRINTS; then
        echov "footprint library/directory heading found"
        match=( ${F_LIB_DIR_MATCH[@]} )
        echov "now looking for: ${match[@]}"
        libList=()
      else
        match=()
      fi

    # if it's not a heading, check for a match
    else
      local removeMatch=false

      for m in ${match[@]}; do
        if [[ $currLine =~ $m ]]; then
          echov "$m found in $currLine"
          currMatch=$m
        fi
      done

      # directory line match
      if [[ $currMatch =~ $DIR_MATCH ]]; then 
        if [[ $currHead =~ $C_DIR_HEAD ]]; then
          local d="$SCRIPT_DIR/components"
        elif [[ $currHead =~ $F_LIB_DIR_HEAD ]]; then
          local d="$SCRIPT_DIR/footprints"
        fi
        # if replace or directory line is empty, just put in the directory
        local emptyLine="=$"
        if $REPLACE || [[ $currLine =~ $emptyLine ]]; then
          
            echov "replacing directory"
            outLine="$DIR_MATCH=$d"
        # if not replace, then add it to the end with a semicolon
        else
          echov "appending directory"
          outLine="$outLine;$d"
        fi
        # remove match from array
        removeMatch=true
          
      # library line match - build array if not replacing
      elif [[ $currMatch =~ $LIB_MATCH ]]; then
        removeMatch=false
        lookingForEnd=true
        write=false
        if ! $REPLACE; then
          libList+=( `echo $currLine | grep -o '[^=]*$'` )
        fi
      fi

      # remove from the match array if necessary
      if $removeMatch; then
        match=( ${match[@]/$m/} )
      fi
    fi

    if $write
      then
      echov -e "out:\t$outLine\n"
      echo "$outLine" >> $P.temp
    fi
  done <$P

  # if end of file reached and still looking for the end of a section, take care of it
  if $lookingForEnd; then
    echov "end of file"
    if [[ $currMatch =~ $LIB_MATCH ]]; then
      echov "fixing libraries"
      # components
      if [[ $currHead =~ $C_LIB_HEAD ]]; then
        if $PREPEND; then
          libList=( ${COMPS[@]} ${libList[@]} )
        elif $APPEND; then
          libList=( ${libList[@]} ${COMPS[@]}  )
        else
          libList=${COMPS[@]}
        fi
      # footprints
      elif [[ $currHead =~ $F_LIB_DIR_HEAD ]]; then
        if $PREPEND; then
          libList=( ${FOOTS[@]} ${libList[@]} )
        elif $APPEND; then
          libList=( ${libList[@]} ${FOOTS[@]}  )
        else
          libList=${FOOTS[@]}
        fi
      fi

      # loop and fix the libs
      local libNum=1
      for li in ${libList[@]}; do
        local output="$LIB_MATCH$libNum=$li"
        echov -e "out:\t$output"
        echo $output >> $P.temp
        let libNum++
      done
      echov "all libraries outputted"
    fi
  fi
}

function cleanup () {
  mv -f $P.temp $P
}

# debugging on/off
function echov () {
  if $VERBOSE; then
    command echo $@
  fi
}

# start the script
go $@
